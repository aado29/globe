<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - Subdivisions with Catmull-Clark</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="http://threejs.org/examples/js/libs/tween.min.js"></script>

		<script>

			var container;

			var camera, group, controls, scene, renderer;

			var mouseX = -200, mouseY = 200, windowHalfX = window.innerWidth / 2, windowHalfY = window.innerHeight / 2;

			var info;

			var geometry, radius = 200;

			// start scene

			init();
			animate();

			function updateInfo() {

				var text = 'Drag to spin THREE';

				info.innerHTML = text;

			}

			function addBackground() {

				var loader = new THREE.TextureLoader();
				loader.load(
					'globe.png',
					function ( image ) {
						var bgMaterial = new THREE.MeshBasicMaterial( {
							map: image,
							transparent: true,
							opacity: 0.5,
							color: 0xCCCCCC
						} );
						var bg = new THREE.Mesh( 
							new THREE.PlaneGeometry(radius * 2.2, radius * 2.2),
							bgMaterial
						);

						scene.add(bg);
					}
				);
			}

			function addStuff() {

				if ( window.group !== undefined ) {

					scene.remove( group );

				}

				geometry = new THREE.IcosahedronGeometry( radius, 1 );

				// scale geometry to a uniform size
				geometry.computeBoundingSphere();

				var scaleFactor = 160 / geometry.boundingSphere.radius;
				geometry.scale( scaleFactor, scaleFactor, scaleFactor );

				var originalGeometry = geometry.clone();
				originalGeometry.computeFaceNormals();
				originalGeometry.computeVertexNormals( true );

				// in case of duplicated vertices
				geometry.mergeVertices();
				geometry.computeFaceNormals();
				geometry.computeVertexNormals( true );

				updateInfo();

				group = new THREE.Group();
				scene.add( group );

				var canvas, size = 256;

				// create canvas
				canvas = document.createElement( 'canvas' );
				canvas.width = size;
				canvas.height = size;

				// get context
				var context = canvas.getContext( '2d' );

				// draw gradient
				context.rect( 0, 0, size, size );
				var gradient = context.createLinearGradient( 0, 0, size, size );
				gradient.addColorStop(0.2, '#1f9ae5'); // blue light 
				gradient.addColorStop(1, '#1ec480'); // green
				context.fillStyle = gradient;
				context.fill();

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				var mesh = new THREE.Mesh(
					geometry
					, new THREE.MeshBasicMaterial( { 
						color: 0xfefefe,
						wireframe: true,
						wireframeLinewidth: 2,
						opacity: 0.5,
						map: texture
					} ) );
				group.add( mesh );

				var fvNames = [ 'a', 'b', 'c', 'd' ];

				for( var f = 0, fl = mesh.geometry.faces.length; f < fl; f ++ ) {
					var face = mesh.geometry.faces[ f ];
					if( face.vertexNormals === undefined ) {
						continue;
					}
					for( var v = 0, vl = face.vertexNormals.length; v < vl; v ++ ) {
						var coor = mesh.geometry.vertices[ face[ fvNames[ v ] ] ];

						var texture = new THREE.Texture( canvas );
						texture.needsUpdate = true; // important!

						var particle = new THREE.Mesh( 
							new THREE.SphereGeometry( 0.5, 32, 32 )
							, new THREE.MeshBasicMaterial( { opacity: 1, map: texture, transparent: true} ) 
						);
						particle.position.set( coor.x, coor.y, coor.z);
						particle.scale.set( 12, 12, 12 );
						mesh.add( particle );
					}
				}

				addBackground();

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				var light = new THREE.PointLight( 0xffffff, 1.5 );
				light.position.set( 1000, 1000, 2000 );
				scene.add( light );

				addStuff();

				renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				controls = new THREE.OrbitControls( camera, renderer.domElement );

				window.addEventListener( 'click', onWindowClick, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onWindowClick( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );

				new TWEEN.Tween( group.rotation ).to( {
					x: ( mouseX ) / 100,
					y: ( mouseY ) / 100 
				}, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				controls.update();

				render();

			}

			function render() {

				TWEEN.update();

				// group.rotation.x += ( mouseX - group.rotation.x ) * 0.9;
				// group.rotation.y += ( mouseY - group.rotation.y ) * 0.9;

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>