<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - Subdivisions with Catmull-Clark</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>
		<script src="http://threejs.org/examples/js/libs/tween.min.js"></script>

		<script>

			var container;

			var camera, globeGroup, nodeGroup, infoGroup, scene, renderer;

			var mouseX = -200, mouseY = 200, windowHalfX = window.innerWidth / 2, windowHalfY = window.innerHeight / 2;

			var particles = [];

			var geometry, radius = 200;

			var itemsLeft = [
				{
					x: -70, //coordenada x
					y: 200,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight:null,
					minHeight:null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
				{
					x: -220,
					y: 200,
					dx: 0.3,
					dy: 0.4,
					maxWidth: -220 + 25,
					minWidth: -220 - 25,
					maxHeight: 200 + 25,
					minHeight: 200 - 25,
					particle: null,
					text: null,
					name: 'Innovacion\ny liderazgo',
					desc: 'Lorem Ipsum dolor',
					size: 12
				},
				{
					x: -203,
					y: 80,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight:null,
					minHeight:null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
				{
					x: -280,
					y: 70,
					dx: 0.2,
					dy: 0.4,
					maxWidth: -280 + 23,
					minWidth: -280 - 23,
					maxHeight: 70 + 20,
					minHeight: 70 - 20,
					particle: null,
					text: null,
					name: 'Equipo\nMultidiplinario',
					desc: 'Lorem Ipsum dolor',
					size: 8
				},
				{
					x: -280,
					y: -50,
					dx: 0.2,
					dy: 0.6,
					maxWidth: -280 + 25,
					minWidth: -280 - 25,
					maxHeight: -50 + 28,
					minHeight: -50 - 28,
					particle: null,
					text: null,
					name: 'Partner de\nConfianza',
					desc: 'Lorem Ipsum dolor',
					size: 9
				},
				{
					x: -168,
					y: -125,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight:null,
					minHeight:null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
				{
					x: -260,
					y: -200,
					dx: 0.5,
					dy: 0.2,
					maxWidth: -260 + 25,
					minWidth: -260 - 25,
					maxHeight: -200 + 28,
					minHeight: -200 - 28,
					particle: null,
					text: null,
					name: 'Certificaciones',
					desc: 'Lorem Ipsum dolor',
					size: 10
				}
			];

			var itemsRight = [
				{
					x: 240,
					y: 200,
					dx: 0.5,
					dy: 0.3,
					maxWidth: 240 + 20,
					minWidth: 240 - 20,
					maxHeight: 200 + 20,
					minHeight: 200 - 20,
					particle: null,
					text: null,
					name: 'Visionarios',
					desc: 'Lorem Ipsum dolor',
					size: 5
				},
				{
					x: 155,
					y: 140,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight: null,
					minHeight: null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
				{
					x: 250,
					y: 80,
					dx: 0.3,
					dy: 0.4,
					maxWidth: 250 + 20,
					minWidth: 250 - 20,
					maxHeight: 80 + 20,
					minHeight: 80 - 20,
					particle: null,
					text: null,
					name: 'Expertise',
					desc: 'Lorem Ipsum dolor1',
					size: 8
				},
				{
					x: 290,
					y: -80,
					dx: 0.4,
					dy: 0.2,
					maxWidth: 290 + 20,
					minWidth: 290 - 20,
					maxHeight: -80 + 20,
					minHeight: -80 - 20,
					particle: null,
					text: null,
					name: 'Responsabilidad\nSocial',
					desc: 'Lorem Ipsum dolor1',
					size: 9
				},
				{
					x: 205,
					y: -80,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight: null,
					minHeight: null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
				{
					x: 250,
					y: -200,
					dx: 0.2,
					dy: 0.3,
					maxWidth: 250 + 20,
					minWidth: 250 - 20,
					maxHeight: -200 + 20,
					minHeight: -200 - 20,
					particle: null,
					text: null,
					name: 'Alianzas\nEstrategicas',
					desc: 'Lorem Ipsum dolor1',
					size: 6
				},
				{
					x: 140,
					y: -140,
					dx: 0,
					dy: 0,
					maxWidth: null,
					minWidth: null,
					maxHeight: null,
					minHeight: null,
					particle: null,
					text: null,
					name: '',
					desc: '',
					size: 1
				},
			];

			var listR, listL;

			// start scene

			init();
			animate();

			function handleClickParticle(event) {

				var raycaster = new THREE.Raycaster(),
					mouse = new THREE.Vector2(),
					sphereRadius = 105;

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(particles);

				if (intersects.length > 0){

					if ( window.infoGroup !== undefined ) {
						scene.remove( infoGroup ); // Se remueve si el gupo existe
					}

					infoGroup = new THREE.Group();
					scene.add( infoGroup );

					// Use the intersected objects: 
					// intersects[0] represents the foremost object that was hovered
					var message = intersects[0].object.name;

					var canvas = document.createElement('canvas');
					canvas.width = sphereRadius * 2;
					canvas.height = sphereRadius * 2;

					var ctx = canvas.getContext('2d');

					ctx.fillStyle = "rgba(204, 204, 204, 0.8)";
					ctx.fillRect(0,0,canvas.width,canvas.height);

					ctx.font = "Bold 12px Arial";
					ctx.fillStyle = "#000000";
					ctx.textAlign = "center";
					ctx.fillText(message, canvas.width/2, canvas.width/2);

					// canvas contents will be used for a texture
					var txtr = new THREE.Texture(canvas);
					txtr.needsUpdate = true;

					var geometry = new THREE.CircleGeometry( sphereRadius, 50 );
					var material = new THREE.MeshBasicMaterial( {map: txtr, side:THREE.DoubleSide } );
					material.transparent = true;
					var overlay = new THREE.Mesh( geometry, material );
					overlay.position.x = 0;
					overlay.position.y = 0;
					overlay.position.z = 200;

					infoGroup.add( overlay );


				} else {

					if ( window.infoGroup !== undefined ) {
						scene.remove( infoGroup ); // Se remueve si el gupo existe
					}

				}

			}

			function handleHoverParticle(event) {

				var raycaster = new THREE.Raycaster(),
					mouse = new THREE.Vector2();

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(particles);

				if (intersects.length > 0){

					window.document.body.style.cursor = 'pointer';
					console.log(intersects[0]);

				} else {

					window.document.body.style.cursor = 'auto';

				}

			}

			function addBackground() {

				var loader = new THREE.TextureLoader();
				loader.load(
					'globe.png',
					function ( image ) {
						var bg = new THREE.Mesh( 
							new THREE.PlaneGeometry(radius * 2.2, radius * 2.2),
							new THREE.MeshBasicMaterial( {
								map: image,
								transparent: true,
								opacity: 0.5,
								color: 0xCCCCCC
							} )
						);

						scene.add(bg);
					}
				);

			}

			function createGlobeTexture() {

				var canvas, size = 256;

				// create canvas
				canvas = document.createElement( 'canvas' );
				canvas.width = size;
				canvas.height = size;

				// get context
				var context = canvas.getContext( '2d' );

				// draw gradient
				context.rect( 0, 0, size, size );
				var gradient = context.createLinearGradient( 0, 0, size, size );
				gradient.addColorStop(0.2, '#1f9ae5'); // blue light 
				gradient.addColorStop(1, '#1ec480'); // green
				context.fillStyle = gradient;
				context.fill();

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				return texture;

			}

			function drawGlobe() {

				if ( window.globeGroup !== undefined ) {
					scene.remove( globeGroup ); // Se remueve si el gupo existe
				}

				globeGroup = new THREE.Group();
				scene.add( globeGroup );

				geometry = new THREE.IcosahedronGeometry( radius, 1 );

				// scale geometry to a uniform size
				geometry.computeBoundingSphere();

				var scaleFactor = 160 / geometry.boundingSphere.radius;
				geometry.scale( scaleFactor, scaleFactor, scaleFactor );

				// in case of duplicated vertices
				geometry.mergeVertices();
				geometry.computeFaceNormals();
				geometry.computeVertexNormals( true );

				var mesh = new THREE.Mesh(
					geometry
					, new THREE.MeshBasicMaterial( { 
						color: 0xfefefe,
						wireframe: true,
						wireframeLinewidth: 2,
						opacity: 0.5,
						map: createGlobeTexture()
					} ) );
				globeGroup.add( mesh );

				var fvNames = [ 'a', 'b', 'c' ];

				for( var f = 0, fl = mesh.geometry.faces.length; f < fl; f ++ ) {
					var face = mesh.geometry.faces[ f ];
					if( face.vertexNormals === undefined ) {
						continue;
					}
					for( var v = 0, vl = face.vertexNormals.length; v < vl; v ++ ) {
						var coor = mesh.geometry.vertices[ face[ fvNames[ v ] ] ];

						var particle = new THREE.Mesh( 
							new THREE.SphereGeometry( 0.5, 32, 32 ),
							new THREE.MeshBasicMaterial( {
								opacity: 1, 
								map: createGlobeTexture(),
								transparent: true
							} ) 
						);
						particle.position.set( coor.x, coor.y, coor.z);
						particle.scale.set( 12, 12, 12 );
						// mesh.add( particle );
						globeGroup.add( particle );
					}
				}

			}

			function addStuff() {

				drawGlobe();
				addBackground();
				drawLandscape();

			}

			function makeTextSprite( message, pos, align ) {

				var lineHeight = 20,
					w = 256,
					h = 128,
					margin = 20;

				var canvas = document.createElement('canvas');
				canvas.width = w;
				canvas.height = h;

				var ctx = canvas.getContext('2d');

				// fill the canvas
				// ctx.fillStyle = "rgba(204, 204, 204, 0.8)";
				// ctx.fillRect(0,0,w,h);	

				var arrMessage = message.split('\n');
				for (var i = 0; i < arrMessage.length; i++) {

					ctx.fillStyle = "#444444";
					ctx.font = "Bold 20px Arial";
					if (align == 'right') {
						ctx.textAlign = "left";
						if (arrMessage.length < 2)
							ctx.fillText(arrMessage[i].toUpperCase(), 0 + margin, h/2 + lineHeight/2 );
						else
							ctx.fillText(arrMessage[i].toUpperCase(), 0 + margin, lineHeight * ( i + 1 ) + ( arrMessage.length * lineHeight ) );
					} else {
						ctx.textAlign = "right";
						if (arrMessage.length < 2)
							ctx.fillText(arrMessage[i].toUpperCase(), w - margin, h/2 + lineHeight/2 );
						else
							ctx.fillText(arrMessage[i].toUpperCase(), w - margin, ( lineHeight * ( i + 1 ) + ( arrMessage.length * lineHeight ) / 1 ) );
					}
				}

				// canvas contents will be used for a texture
				var txtr = new THREE.Texture(canvas);
				txtr.needsUpdate = true;

				var material = new THREE.MeshBasicMaterial( {map: txtr, side:THREE.DoubleSide } );
				material.transparent = true;

				var sprite = new THREE.Mesh(
					new THREE.PlaneGeometry(canvas.width, canvas.height),
					material
				);

				sprite.name = 'message';
				sprite.position.set(pos.x , pos.y, 1);

				return sprite;

			}

			function createItemList(pos, text, align, group) {

				var bg = makeTextSprite(text, pos, align);
				group.add(bg);

				return bg;

			}

			function drawLandscape() {

				if ( window.nodeGroup !== undefined ) {
					scene.remove( nodeGroup ); // Se remueve si el gupo existe
				}

				nodeGroup = new THREE.Group();
				scene.add( nodeGroup );

				var material = new THREE.LineBasicMaterial({
					color: 0xCCCCCC,
					linewidth: 1.5
				});

				if (itemsLeft.length > 0) {
					var skullList = new THREE.Geometry();
					for (var i = 0; i < itemsLeft.length; i++) {
						var self = itemsLeft[i];
						skullList.vertices.push(
							new THREE.Vector3(self.x, self.y, 1)
						);
						self.particle = drawParticle(
							{x: self.x, y: self.y, z: 1},
							self.desc,
							self.size,
							nodeGroup
						);
						self.text = createItemList(
							{x: self.x, y: self.y, z: 0},
							self.name,
							'left',
							nodeGroup
						);
					}
					listL = new THREE.Line( skullList, material );
					scene.add( listL );
				}

				if (itemsRight.length > 0) {
					var skullList = new THREE.Geometry();
					for (var i = 0; i < itemsRight.length; i++) {
						var self = itemsRight[i];
						skullList.vertices.push(
							new THREE.Vector3(self.x, self.y, 1)
						);
						self.particle = drawParticle(
							{x: self.x, y: self.y, z: 1},
							self.desc,
							self.size,
							nodeGroup
						);
						self.text = createItemList(
							{x: self.x, y: self.y, z: 0},
							self.name,
							'right',
							nodeGroup
						);
					}
					listR = new THREE.Line( skullList, material );
					scene.add( listR );
				}

			}

			function animateList() {

				listL.geometry.verticesNeedUpdate = true;
				var verticesL = listL.geometry.vertices;

				for (var i = 0; i < itemsLeft.length; i++) {
					var vertice = verticesL[i],
						item = itemsLeft[i];

					vertice.setX( item.x );
					vertice.setY( item.y );

					item.particle.position.set(item.x, item.y, 1);
					item.text.position.set(item.x - item.text.geometry.parameters.width / 2, item.y, 1);

					if (item.x + item.dx > item.maxWidth || item.x + item.dx < item.minWidth)
						item.dx = -item.dx;
					if (item.y + item.dy > item.maxHeight || item.y + item.dy < item.minHeight)
						item.dy = -item.dy;

					item.x += item.dx;
					item.y += item.dy;
				}

				listR.geometry.verticesNeedUpdate = true;
				var verticesR = listR.geometry.vertices;

				for (var i = 0; i < itemsRight.length; i++) {
					var vertice = verticesR[i],
						item = itemsRight[i];

					vertice.setX( item.x );
					vertice.setY( item.y );

					item.particle.position.set(item.x, item.y, 1);
					item.text.position.set(item.x + item.text.geometry.parameters.width / 2, item.y, 1);

					if (item.x + item.dx > item.maxWidth || item.x + item.dx < item.minWidth)
						item.dx = -item.dx;
					if (item.y + item.dy > item.maxHeight || item.y + item.dy < item.minHeight)
						item.dy = -item.dy;

					item.x += item.dx;
					item.y += item.dy;
				}

			}

			function drawParticle(pos, desc, size, group) {

				var geometry = new THREE.CircleGeometry( size, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xCCCCCC} );
				var particle = new THREE.Mesh( geometry, material );
				particle.position.x = pos.x;
				particle.position.y = pos.y;
				particle.position.z = pos.z;
				particle.name = desc

				particles.push( particle );
				group.add(particle);

				return particle;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				var light = new THREE.PointLight( 0xffffff, 1.5 );
				light.position.set( 1000, 1000, 2000 );
				scene.add( light );

				addStuff();

				renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.domElement.addEventListener('click', handleClickParticle, false);
				renderer.domElement.addEventListener('mousemove', handleHoverParticle, false);

				window.addEventListener( 'click', onWindowClick, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onWindowClick(e) {

				mouseX = ( e.clientX - windowHalfX );
				mouseY = ( e.clientY - windowHalfY );

				new TWEEN.Tween( globeGroup.rotation ).to( {
					x: ( mouseY ) / 100,
					y: - ( mouseX ) / 100 
				}, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

				animateList();
				

			}

			function render() {

				TWEEN.update();

				// globeGroup.rotation.x += ( mouseX - globeGroup.rotation.x ) * 0.9;
				// globeGroup.rotation.y += ( mouseY - globeGroup.rotation.y ) * 0.9;

				console.log()

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>