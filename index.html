<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - Subdivisions with Catmull-Clark</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>
		<script src="http://threejs.org/examples/js/libs/tween.min.js"></script>

		<script>

			var container , def = 0;

			var camera, globeGroup, nodeGroup, infoGroup, scene, renderer;

			var mouseX = -200, mouseY = 200, windowHalfX = window.innerWidth / 2, windowHalfY = window.innerHeight / 2;

			var particles = [];

			var info;

			var listR, listL;

			var geometry, radius = 200;

			var aux = true;

			// start scene

			init();
			animate();

			function handleClickParticle(event) {

				var raycaster = new THREE.Raycaster(),
					mouse = new THREE.Vector2(),
					sphereRadius = 105;

				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera);
				var intersects = raycaster.intersectObjects(particles);

				if (intersects.length > 0){

					if ( window.infoGroup !== undefined ) {
						scene.remove( infoGroup ); // Se remueve si el gupo existe
					}

					infoGroup = new THREE.Group();
					scene.add( infoGroup );

					// Use the intersected objects: 
					// intersects[0] represents the foremost object that was hovered
					var message = intersects[0].object.name;

					var canvas = document.createElement('canvas');
					canvas.width = sphereRadius * 2;
					canvas.height = sphereRadius * 2;

					var ctx = canvas.getContext('2d');

					ctx.fillStyle = "rgba(204, 204, 204, 0.8)";
					ctx.fillRect(0,0,canvas.width,canvas.height);

					ctx.font = "Bold 12px Arial";
					ctx.fillStyle = "#000000";
					ctx.fillText(message, canvas.width/4, canvas.width/4);
					ctx.textAlign = "start";

					// canvas contents will be used for a texture
					var txtr = new THREE.Texture(canvas);
					txtr.needsUpdate = true;

					var geometry = new THREE.CircleGeometry( sphereRadius, 50 );
					var material = new THREE.MeshBasicMaterial( {map: txtr, side:THREE.DoubleSide } );
					material.transparent = true;
					var overlay = new THREE.Mesh( geometry, material );
					overlay.position.x = 0;
					overlay.position.y = 0;
					overlay.position.z = 200;

					infoGroup.add( overlay );


				} else {

					if ( window.infoGroup !== undefined ) {
						scene.remove( infoGroup ); // Se remueve si el gupo existe
					}

				}

			}

			function updateInfo() {

				var text = 'Drag to spin THREE ' + def;

				info.innerHTML = text;

			}

			function addBackground() {

				var loader = new THREE.TextureLoader();
				loader.load(
					'globe.png',
					function ( image ) {
						var bg = new THREE.Mesh( 
							new THREE.PlaneGeometry(radius * 2.2, radius * 2.2),
							new THREE.MeshBasicMaterial( {
								map: image,
								transparent: true,
								opacity: 0.5,
								color: 0xCCCCCC
							} )
						);

						scene.add(bg);
					}
				);

			}

			function createGlobeTexture() {

				var canvas, size = 256;

				// create canvas
				canvas = document.createElement( 'canvas' );
				canvas.width = size;
				canvas.height = size;

				// get context
				var context = canvas.getContext( '2d' );

				// draw gradient
				context.rect( 0, 0, size, size );
				var gradient = context.createLinearGradient( 0, 0, size, size );
				gradient.addColorStop(0.2, '#1f9ae5'); // blue light 
				gradient.addColorStop(1, '#1ec480'); // green
				context.fillStyle = gradient;
				context.fill();

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				return texture;

			}

			function drawGlobe() {

				if ( window.globeGroup !== undefined ) {
					scene.remove( globeGroup ); // Se remueve si el gupo existe
				}

				globeGroup = new THREE.Group();
				scene.add( globeGroup );

				geometry = new THREE.IcosahedronGeometry( radius, 1 );

				// scale geometry to a uniform size
				geometry.computeBoundingSphere();

				var scaleFactor = 160 / geometry.boundingSphere.radius;
				geometry.scale( scaleFactor, scaleFactor, scaleFactor );

				// in case of duplicated vertices
				geometry.mergeVertices();
				geometry.computeFaceNormals();
				geometry.computeVertexNormals( true );

				var mesh = new THREE.Mesh(
					geometry
					, new THREE.MeshBasicMaterial( { 
						color: 0xfefefe,
						wireframe: true,
						wireframeLinewidth: 2,
						opacity: 0.5,
						map: createGlobeTexture()
					} ) );
				globeGroup.add( mesh );

				var fvNames = [ 'a', 'b', 'c' ];

				for( var f = 0, fl = mesh.geometry.faces.length; f < fl; f ++ ) {
					var face = mesh.geometry.faces[ f ];
					if( face.vertexNormals === undefined ) {
						continue;
					}
					for( var v = 0, vl = face.vertexNormals.length; v < vl; v ++ ) {
						var coor = mesh.geometry.vertices[ face[ fvNames[ v ] ] ];

						var particle = new THREE.Mesh( 
							new THREE.SphereGeometry( 0.5, 32, 32 ),
							new THREE.MeshBasicMaterial( {
								opacity: 1, 
								map: createGlobeTexture(),
								transparent: true
							} ) 
						);
						particle.position.set( coor.x, coor.y, coor.z);
						particle.scale.set( 12, 12, 12 );
						// mesh.add( particle );
						globeGroup.add( particle );
					}
				}

			}

			function addStuff() {

				drawGlobe();
				addBackground();
				drawLandscape();

			}

			function makeTextSprite( message, pos, align ) {

				var fontS = 20,
					w = 256,
					h = 128,
					margin = 20,
					x, y;

				var canvas = document.createElement('canvas');
				canvas.width = w;
				canvas.height = h;

				var ctx = canvas.getContext('2d');

				// fill the canvas
				// ctx.fillStyle = "rgba(204, 204, 204, 0.8)";
				// ctx.fillRect(0,0,w,h);

				ctx.fillStyle = "#000000";
				ctx.font = "Bold 20px Arial";

				if (align == 'right') {
					ctx.textAlign = "left";
					x = pos.x + w / 2;
					ctx.fillText(message, 0 + margin, 128/2 + fontS / 2);
				} else {
					ctx.textAlign = "right";
					x = pos.x - w / 2;
					ctx.fillText(message, w - margin, 128/2 + fontS / 2);
				}


				// canvas contents will be used for a texture
				var txtr = new THREE.Texture(canvas);
				txtr.needsUpdate = true;

				var material = new THREE.MeshBasicMaterial( {map: txtr, side:THREE.DoubleSide } );
				material.transparent = true;

				var sprite = new THREE.Mesh(
					new THREE.PlaneGeometry(canvas.width, canvas.height),
					material
				);

				sprite.name = 'message';
				sprite.position.set(x , pos.y, 1);

				return sprite;

			}

			function createItemList(pos, text, align, group) {

				var bg = makeTextSprite(text, pos, align);
				group.add(bg);

			}

			function drawLandscape() {

				var material = new THREE.LineBasicMaterial({
					color: 0xCCCCCC,
					linewidth: 2
				});

				var right = new THREE.Geometry();
				right.vertices.push(
					new THREE.Vector3(radius, radius, 1),
					new THREE.Vector3(radius + 40, radius - 130, 1),
					new THREE.Vector3(radius + 110, radius - 200, 1),
					new THREE.Vector3(radius, -radius, 1)
				);

				var left = new THREE.Geometry();
				left.vertices.push(
					new THREE.Vector3(-radius , radius, 1),
					new THREE.Vector3(-radius - 90, radius - 130, 1),
					new THREE.Vector3(-radius - 50, radius - 220, 1),
					new THREE.Vector3(-radius, -radius, 1)
				);

				listR = new THREE.Line( right, material );
				scene.add( listR );
				listL = new THREE.Line( left, material );
				scene.add( listL );

			}

			function drawParticle(pos, name, desc, align, group) {

				var geometry = new THREE.CircleGeometry( 0.8, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xCCCCCC} );
				var particle = new THREE.Mesh( geometry, material );
				particle.position.x = pos.x;
				particle.position.y = pos.y;
				particle.position.z = pos.z;
				particle.scale.set( 12, 12, 12 );
				particle.name = desc
				// mesh.add( particle );

				particles.push( particle );
				group.add(particle);
				createItemList({x: pos.x, y: pos.y, z: pos.z}, name, align, group);

				return particle;
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				var light = new THREE.PointLight( 0xffffff, 1.5 );
				light.position.set( 1000, 1000, 2000 );
				scene.add( light );

				addStuff();

				renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.domElement.addEventListener('click', handleClickParticle, false);

				window.addEventListener( 'click', onWindowClick, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onWindowClick(e) {

				mouseX = ( e.clientX - windowHalfX );
				mouseY = ( e.clientY - windowHalfY );

				new TWEEN.Tween( globeGroup.rotation ).to( {
					x: ( mouseY ) / 100,
					y: - ( mouseX ) / 100 
				}, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

			function animateList() {

				if ( window.nodeGroup !== undefined ) {
					scene.remove( nodeGroup ); // Se remueve si el gupo existe
				}

				nodeGroup = new THREE.Group();
				scene.add( nodeGroup );

				listL.geometry.verticesNeedUpdate = true;
				var verticesL = listL.geometry.vertices;

				for (var i = 0; i < verticesL.length; i++) {
					verticesL[i].setX( -radius + ( def ) + i*30 );
					verticesL[i].setY( radius + ( def ) + i*30 );
					drawParticle(
						{x:verticesL[i].x, y:verticesL[i].y, z:1},
						'Item '+i,
						'Descripcion',
						'left',
						nodeGroup
					);
				}

				listR.geometry.verticesNeedUpdate = true;
				var verticesR = listR.geometry.vertices;

				for (var i = 0; i < verticesR.length; i++) {
					verticesR[i].setX( radius + ( def ) + i*30 );
					verticesR[i].setY( radius + ( def ) + i*30 );
					drawParticle(
						{x:verticesR[i].x, y:verticesR[i].y, z:1},
						'Item '+i,
						'Descripcion',
						'right',
						nodeGroup
					);
				}

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

				updateInfo();
				if (aux) {
					if (def > 20) {
						aux = false;
					}
					def = def + 0.5;
				} else {
					if (def < -20) {
						aux = true;
					}
					def = def - 0.5;
				}
				animateList();
				

			}

			function render() {

				TWEEN.update();

				// globeGroup.rotation.x += ( mouseX - globeGroup.rotation.x ) * 0.9;
				// globeGroup.rotation.y += ( mouseY - globeGroup.rotation.y ) * 0.9;

				console.log()

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>