<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - Subdivisions with Catmull-Clark</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>
		<script src="http://threejs.org/examples/js/libs/tween.min.js"></script>

		<script>

			var container , def = 0;

			var camera, globeGroup, nodeGroup, scene, renderer;

			var mouseX = -200, mouseY = 200, windowHalfX = window.innerWidth / 2, windowHalfY = window.innerHeight / 2;

			var info;

			var geometry, radius = 200;

			// start scene

			init();
			animate();

			function updateInfo() {

				var text = 'Drag to spin THREE ' + def;

				info.innerHTML = text;

			}

			function addBackground() {

				var loader = new THREE.TextureLoader();
				loader.load(
					'globe.png',
					function ( image ) {
						var bg = new THREE.Mesh( 
							new THREE.PlaneGeometry(radius * 2.2, radius * 2.2),
							new THREE.MeshBasicMaterial( {
								map: image,
								transparent: true,
								opacity: 0.5,
								color: 0xCCCCCC
							} )
						);

						scene.add(bg);
					}
				);

			}

			function drawGlobe() {

				if ( window.globeGroup !== undefined ) {
					scene.remove( globeGroup ); // Se remueve si el gupo existe
				} else {
					globeGroup = new THREE.Group();
					scene.add( globeGroup );
				}

				geometry = new THREE.IcosahedronGeometry( radius, 1 );

				// scale geometry to a uniform size
				geometry.computeBoundingSphere();

				var scaleFactor = 160 / geometry.boundingSphere.radius;
				geometry.scale( scaleFactor, scaleFactor, scaleFactor );

				// in case of duplicated vertices
				geometry.mergeVertices();
				geometry.computeFaceNormals();
				geometry.computeVertexNormals( true );

				var mesh = new THREE.Mesh(
					geometry
					, new THREE.MeshBasicMaterial( { 
						color: 0xfefefe,
						wireframe: true,
						wireframeLinewidth: 2,
						opacity: 0.5,
						map: createGlobeTexture()
					} ) );
				globeGroup.add( mesh );

				var fvNames = [ 'a', 'b', 'c' ];

				for( var f = 0, fl = mesh.geometry.faces.length; f < fl; f ++ ) {
					var face = mesh.geometry.faces[ f ];
					if( face.vertexNormals === undefined ) {
						continue;
					}
					for( var v = 0, vl = face.vertexNormals.length; v < vl; v ++ ) {
						var coor = mesh.geometry.vertices[ face[ fvNames[ v ] ] ];

						var particle = new THREE.Mesh( 
							new THREE.SphereGeometry( 0.5, 32, 32 ),
							new THREE.MeshBasicMaterial( {
								opacity: 1, 
								map: createGlobeTexture(),
								transparent: true
							} ) 
						);
						particle.position.set( coor.x, coor.y, coor.z);
						particle.scale.set( 12, 12, 12 );
						// mesh.add( particle );
						globeGroup.add( particle );
					}
				}

			}

			function createGlobeTexture() {

				var canvas, size = 256;

				// create canvas
				canvas = document.createElement( 'canvas' );
				canvas.width = size;
				canvas.height = size;

				// get context
				var context = canvas.getContext( '2d' );

				// draw gradient
				context.rect( 0, 0, size, size );
				var gradient = context.createLinearGradient( 0, 0, size, size );
				gradient.addColorStop(0.2, '#1f9ae5'); // blue light 
				gradient.addColorStop(1, '#1ec480'); // green
				context.fillStyle = gradient;
				context.fill();

				var texture = new THREE.Texture( canvas );
				texture.needsUpdate = true;

				return texture;

			}

			function addStuff() {

				drawGlobe();
				addBackground();
				drawLandscape();

			}

			function createItemList(pos, text, group, listType) {
				dim = {w: 120, h: 40}

				var bitmap = document.createElement('canvas');
				var g = bitmap.getContext('2d');
				bitmap.width = dim.w;
				bitmap.height = dim.h;
				g.font = 'Bold 20px Arial';

				g.fillStyle = 'white';
				g.fillText(text, 0, 20);
				g.strokeStyle = 'black';
				g.strokeText(text, 0, 20);
				var texture = new THREE.Texture(bitmap) 
				var bg = new THREE.Mesh( 
					new THREE.PlaneGeometry(dim.w, dim.h),
					new THREE.MeshBasicMaterial( {
						map: texture,
						transparent: true,
						opacity: 0.5,
						color: 0xCCCCCC
					} )
				);

				if (listType == 'right')
					bg.position.set(pos.x + (dim.w / 2), pos.y, pos.z - 1);
				else
					bg.position.set(pos.x - (dim.w / 2), pos.y, pos.z - 1);

				group.add(bg);

				console.log(bg.position);
			}

			function drawLandscape() {

				if ( window.nodeGroup !== undefined ) {
					scene.remove( nodeGroup ); // Se remueve si el gupo existe
				} else {
					nodeGroup = new THREE.Group();
					scene.add( nodeGroup );
				}

				drawParticle(radius, radius, 1, 'right');
				drawParticle(radius + 40, radius - 130, 1, 'right');
				drawParticle(radius + 110, radius - 200, 1, 'right');
				drawParticle(radius, -radius, 1, 'right');


				drawParticle(-radius, radius, 1, 'left');
				drawParticle(-radius - 90, radius - 130, 1, 'left');
				drawParticle(-radius - 50, radius - 220, 1, 'left');
				drawParticle(-radius, -radius, 1, 'left');

				var material = new THREE.LineBasicMaterial({
					color: 0xCCCCCC,
					linewidth: 2
				});

				var right = new THREE.Geometry();
				right.vertices.push(
					new THREE.Vector3(radius, radius, 1),
					new THREE.Vector3(radius + 40, radius - 130, 1),
					new THREE.Vector3(radius + 110, radius - 200, 1),
					new THREE.Vector3(radius, -radius, 1)
				);

				var left = new THREE.Geometry();
				left.vertices.push(
					new THREE.Vector3(-radius, radius, 1),
					new THREE.Vector3(-radius - 90, radius - 130, 1),
					new THREE.Vector3(-radius - 50, radius - 220, 1),
					new THREE.Vector3(-radius, -radius, 1)
				);

				var line = new THREE.Line( right, material );
				nodeGroup.add( line );
				var line = new THREE.Line( left, material );
				nodeGroup.add( line );

			}

			function drawParticle(x, y, z, group) {

				var geometry = new THREE.CircleGeometry( 0.8, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xCCCCCC} );
				var particle = new THREE.Mesh( geometry, material );
				particle.position.x = x;
				particle.position.y = y;
				particle.position.z = z;
				particle.scale.set( 12, 12, 12 );
				// mesh.add( particle );

				nodeGroup.add( particle );
				createItemList({x: x, y: y, z: z}, 'Item', nodeGroup, group);
				console.log(particle.position);

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				scene = new THREE.Scene();

				var light = new THREE.PointLight( 0xffffff, 1.5 );
				light.position.set( 1000, 1000, 2000 );
				scene.add( light );

				addStuff();

				renderer = new THREE.WebGLRenderer( { antialias: true } ); // WebGLRenderer CanvasRenderer
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'click', onWindowClick, false );
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onWindowClick(e) {

				mouseX = ( e.clientX - windowHalfX );
				mouseY = ( e.clientY - windowHalfY );

				new TWEEN.Tween( globeGroup.rotation ).to( {
					x: ( mouseX ) / 100,
					y: ( mouseY ) / 100 
				}, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

				updateInfo();
				def++;

			}

			function render() {

				TWEEN.update();

				// globeGroup.rotation.x += ( mouseX - globeGroup.rotation.x ) * 0.9;
				// globeGroup.rotation.y += ( mouseY - globeGroup.rotation.y ) * 0.9;

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>